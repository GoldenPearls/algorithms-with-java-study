### 1. Palindrome Linked List

* **파일**: `palindrome-linked-list.java`
* **링크**: [LeetCode 234. Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/description/)
* **난이도**: Easy
* **요약**: 단일 연결 리스트가 주어졌을 때, 순서가 앞뒤로 대칭(palindrome)인지 판별하는 문제
* **핵심 아이디어**:

    1. **Divide**: Fast/Slow 포인터로 리스트의 중간 지점 찾기
    2. **Modify**: 중간 이후 절반을 제자리에서 뒤집기(역순화)
    3. **Detect**: 앞쪽과 뒤집힌 뒤쪽을 나란히 이동하며 값 비교
    4. 홀수 길이일 경우 가운데 노드는 비교에서 제외

#### **시간복잡도**:

    * 중간 찾기: O(n)
    * 뒤집기: O(n)
    * 비교: O(n)
    * 전체 = O(n + n + n) = O(3n) → **O(n)**
* **공간복잡도**: O(1) (추가 포인터 변수만 사용)
* **학습 포인트**:

    * **포인터 활용**: fast/slow 포인터를 통한 리스트 절반 분할
    * **연결 리스트 조작**: 절반만 역순화해 공간 절약
    * **불변식 유지**: 홀수 길이에서는 중앙 노드 무시 가능 → 결과에 영향 없음

---
### 21. Merge Two Sorted Lists

* **파일**: `21-merge-two-sorted-lists.java`
* **링크**: [LeetCode 21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/description/)
* **난이도**: Easy

#### 🧩 요약

두 개의 **오름차순(비내림차순)** 단일 연결 리스트 `list1`, `list2`가 주어질 때, **기존 노드들을 이어붙여** 하나의 정렬된 리스트로 병합하여 head를 반환합니다.

#### 핵심 아이디어

1. **더미(dummy) 노드**를 하나 두고, 결과 리스트의 시작을 고정한다.
2. `list1.val` 과 `list2.val`을 비교해 **더 작은 노드**를 결과 뒤에 붙이고, 해당 리스트 포인터를 **앞으로 이동**한다.
3. 둘 중 하나가 끝나면, **나머지 리스트 전체를 통째로** 결과 뒤에 연결한다.
4. 최종 반환은 `dummy.next` (dummy 자신은 버림).

#### 풀이 요약

* 포인터 이동만으로 **기존 노드**를 연결 → 값 복사/새 노드 생성 불필요
* 한 번의 병합 과정으로 **시간 O(n + m)** (n, m은 각 리스트 길이)
* 추가 공간은 포인터 몇 개뿐 → **공간 O(1)**

#### 학습 포인트

* **더미 노드 패턴**: 헤드 처리를 단순화(빈 리스트/첫 연결 시 분기 제거).
* **불변식 유지**: 매 반복 후에도 결과 리스트는 항상 정렬 상태 유지.
* **공간 최적**: **기존 노드 재활용**으로 메모리 사용 최소화(O(1)).

#### 시간 복잡도
- 두 리스트를 한 번만 순회하면서 병합 → O(n + m)
- (n = list1 길이, m = list2 길이)

> 전체 = O(n + m)

#### 공간 복잡도
- 추가로 사용하는 포인터 변수(dummy, tail, 비교용) → O(1)
- 기존 노드들을 재활용하므로 별도 배열이나 리스트 공간 필요 없음

> 전체 = O(1)
