# 561. Array Partition

결국 숫자의 크기별로 정렬한 후 2개씩 분리하고 최소값을 찾는 문제이기 때문에 아래와 같은 법칙이 성립
[1, 4, 3, 2] -> [1, 2, 3, 4] -> min(1, 2) + min(3, 4) -> 1 + 3 -> 4

## 기본적인 해법
정렬 후에 홀수번째 값만 sum
최종 시간복잡도 O(n log n) + O(1/2n) -> O(n log n) (n은 nums의 길이)
최종 공간복잡도: O(1)

## 최적화 해법
값의 범위가 제한적이므로 배열을 생성하여 counting, 음수처리를 위해 OFFSET을 포함하여 저장 후 최종적으로는 OFFSET을 뺀 원래값을 확인하여 합산
정렬에 사용되는 기본적인  시간복잡도인 n log n을 제거하고 O(n)으로 풀어낼 수 있다

(n은 nums.length라고 했을 때)
전체 시간복잡도(Time Complexity): O(20001) + O(n) + O(20001) -> O(20001)은 O(n + 1)이므로 O(3n + 2) -> O(n)
전체 공간복잡도(Space Complexity): O(1) + O(1) + O(20001) + O(1) -> O(n) -> O(2n + 4) -> O(n)

# 121. Best Time to Buy and Sell Stock

## 기본적인 해법 
한 번 순회하면서 maxProfit, minPrice를 현재값과 비교해서 갱신
최종 시간복잡도 O(n)
최종 공간복잡도: O(1) + O(1) -> O(2) -> O(1)

## 최적화 해법
최소값 계산만 매번 수행하고 조건부로 최대값 갱신. (어차피 매번 수행해야 하는) 최소값 계산 결과에 따라 조건부로 최대값 갱신로직을 수행하므로 미세하지만 성능향상. 편의상 생략하고 있지만 모든 로직을 실행할때 O(1)의 시간복잡도 발생. 

### 기존로직
매 순회마다 최소값 계산 O(1) + 최대값 계산 O(1) -> O(2) 
### 최적화 방안
최소값 계산 O(1) + 최대값 계산 O(0 또는 1) -> O(2 이하)

(prices.lenght를 n이라고 했을 때)
최종 시간복잡도 O(n)
최종 공간복잡도: O(1) + O(1) -> O(2) -> O(1)