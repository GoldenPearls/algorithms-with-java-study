# 📘 🔹 \[561] Array Partition

* **문제 링크:** [LeetCode 561. Array Partition](https://leetcode.com/problems/array-partition/description/)

> 각 쌍의 최소값의 합을 최대화하기 위해 요소를 쌍으로 묶을 때, 최적의 전략은 **가장 작은 숫자들을 인접하게 묶는 것**입니다.
> 이렇게 하면 큰 숫자를 최소값으로 “낭비”하지 않게 됩니다.

---

## 🥇 최초 접근 (Solution.java)

<img width="714" height="444" alt="image" src="https://github.com/user-attachments/assets/6cf58c90-3c3c-4101-b3e2-f1783f8f431f" />


### **힌트 기반 아이디어**

* 1차 힌트: “오름차순으로 정렬한 뒤, 인접한 두 개씩 묶고 각 쌍의 첫 번째 원소들만 전부 더해봐.”
* 2차 힌트: "정렬 후 짝수 인덱스 값들을 더한 합을 그대로 반환하면 돼."

---

### **풀이 요약**

1. 배열을 오름차순으로 정렬한다.
2. 인접한 두 개씩 `(nums[0], nums[1])`, `(nums[2], nums[3])` … 묶는다.
3. 각 쌍의 최소값은 항상 짝의 **앞 원소(짝수 인덱스)** 이므로 → 짝수 인덱스 원소를 전부 합한다.

---

### **Java 코드**

```java
import java.util.Arrays;

class Solution {
    public int arrayPairSum(int[] nums) {
        Arrays.sort(nums); // 오름차순 정렬
        int sum = 0;
        for (int i = 0; i < nums.length; i += 2) {
            sum += nums[i]; // 짝수 인덱스 값 더하기
        }
        return sum;
    }
}
```

---

### **예제 입출력**

```text
Input: nums = [1,4,3,2]
Output: 4
설명: (1,2), (3,4) 로 묶으면 min(1,2)+min(3,4)=1+3=4 → 최대값

Input: nums = [6,2,6,5,1,2]
Output: 9
설명: (1,2), (2,5), (6,6) → 1+2+6=9
```

---

### **복잡도**

* **시간복잡도:** `O(n log n)` (정렬)
* **공간복잡도:** `O(log n)` (정렬 과정에서의 스택 메모리)

---
####🔎 QuickSort 시간 복잡도 분석

1. 분할 과정 (Partition)

* 배열에서 pivot을 기준으로 **작은 값 / 큰 값** 으로 나눔.
* 이때 배열의 **모든 원소를 한 번씩 비교**해야 해요.
* 즉, **한 번 분할하는 데 O(n)** 시간이 걸립니다.

2. 재귀 호출 (Divide & Conquer)

* 배열이 반씩 쪼개진다고 가정하면 → 높이가 `log n` 인 **재귀 트리**가 생깁니다.
* 각 레벨에서 처리하는 원소 개수는 `n` 개로 동일합니다.

📌 예시: `n = 8`일 때

```
Level 1 (루트):     8개 처리  → O(8)
Level 2:           4+4개 처리 → O(8)
Level 3:         2+2+2+2개   → O(8)
Level 4 (리프):  1+1+1+...   → O(8)
```

➡ 각 레벨의 총 연산량은 항상 O(n).
➡ 레벨은 최대 log n.

3. 총 시간

* 한 레벨 = O(n)
* 레벨 개수 = O(log n)
* 따라서 전체 = **O(n log n)**

**📊 직관 그림 (QuickSort 시간 복잡도 트리)**

```
         n          ← 전체 n개 비교
       /   \
     n/2   n/2      ← 총합 n
    / \    / \
  n/4 n/4 n/4 n/4   ← 총합 n
  ... 계속 ...
  최종 log n 단계
```

👉 각 단계에서 **총 비교 연산량이 n으로 유지**되기 때문에, 깊이가 log n이므로 `n * log n` 이 되는 거예요.


**🚨 예외: 최악의 경우**

* Pivot이 매번 한쪽 끝값으로만 잡히면 → 매번 `n-1` vs `1` 분할
* 트리 깊이가 `n`이 되어 총 시간은 `O(n^2)`
* 하지만 **Dual-Pivot QuickSort** 같은 구현은 보통 랜덤/중간 pivot을 써서 평균적으로 `O(n log n)`을 유지합니다.


---
### 공간 복잡도에 대한 계산 방법
1. **입력 자체는 제외**

   * `nums` 배열은 이미 주어진 입력 → 공간 복잡도 계산에서는 보통 제외합니다.
   * 즉, **추가로 쓰는 메모리**만 고려해요.

2. **코드 분석하기**

   ```java
   Arrays.sort(nums);
   int sum = 0;
   for (int i = 0; i < nums.length; i += 2) {
       sum += nums[i];
   }
   return sum;
   ```

   * `sum` → 정수형 변수 하나 (O(1))
   * `i` → 반복문 변수 하나 (O(1))
   * 정렬에서 쓰이는 추가 메모리 → **정렬 알고리즘 구현 방식에 따라 다름**

3. **정렬 알고리즘에 따른 차이**
   * 자바의 `Arrays.sort(int[])` 는 **Dual-Pivot QuickSort** 를 사용해요.

     * 최악의 경우 재귀 깊이에 따라 `O(log n)` 스택 공간 사용.
   * 만약 `Arrays.sort(Object[])` 였다면 **TimSort** 를 써서 `O(n)` 보조 배열 공간이 필요할 수도 있음.
  
---

### 추가 정리 🔎 자바 `Arrays.sort(int[])` 내부 동작

* **Dual-Pivot QuickSort** 를 사용합니다.
* QuickSort는 **분할 정복(divide & conquer)** 알고리즘이에요.

> 👉 핵심 아이디어:
1. 배열에서 기준점(피벗)을 정한다.
2. 피벗보다 작은 값들은 왼쪽, 큰 값들은 오른쪽으로 분할한다.
3. 왼쪽 부분과 오른쪽 부분을 다시 **재귀적으로 정렬**한다.

**📊 재귀 호출 구조**

배열 크기 `n = 8`인 경우를 생각해볼게요.

```
정렬([1,4,3,2,  7,6,5,8])
 ├─ 정렬([1,2,3,4])   // 왼쪽
 │   ├─ 정렬([1,2])   // 더 쪼갬
 │   └─ 정렬([3,4])   
 └─ 정렬([5,6,7,8])   // 오른쪽
     ├─ 정렬([5,6])
     └─ 정렬([7,8])
```

**각 단계에서 스택 프레임이 쌓임**
<img width="1639" height="1286" alt="output" src="https://github.com/user-attachments/assets/9879ed32-2b02-4d92-93a9-f3f3f0dacac4" />

* QuickSort는 재귀적으로 불리니까, 호출할 때마다 “현재 구간의 시작/끝 인덱스” 같은 정보가 **스택에 저장**돼요.
* 배열을 반씩 나눈다고 하면 → 재귀 깊이는 `log n` 단계까지 내려감.

* 한 레벨 = O(n)
* 레벨 개수 = O(log n)

> 따라서 전체 = O(n log n)

#### 공간 복잡도 계산

* 각 재귀 호출에서 스택 프레임 하나 차지 → `O(1)`
* 재귀 깊이가 최대 `log n` → **총 O(log n)**

총 공간 = O(log n) + O(1) = O(log n + 1) = O(log n)  // 마지막에 상수항

> 이렇게 **깊이만큼만 스택 공간이 필요**하기 때문에 O(log n)이에요.

---

### **Edge Cases**

* `n = 1`일 때 → 그냥 두 수 중 작은 수가 답.
* `nums`가 음수 포함해도 정렬 후 짝수 인덱스 합을 구하면 정답.

---

### **왜 정렬이 최적인가?**

* 큰 수가 작은 수와 짝지어지면, 그 큰 수는 최소값 계산에서 **무시**된다.
* 따라서 큰 수를 낭비하지 않으려면 → **비슷한 크기끼리 묶는 게 최적**.
* 정렬 후 인접한 원소를 묶으면 이 전략을 자동으로 만족한다.

---

### **추가 Tip**

* 각 쌍에서 **큰 수는 항상 버려진다.**
* 큰 수가 작은 수보다 1 크든 1000 크든, `min`은 결국 작은 수이므로 동일하다.
* 따라서 작은 수를 최대한 살리는 전략 → **짝수 인덱스 합**.

---

## ⚡ 최적화 접근 (OptimizedSolution.java — Counting Scan)

<img width="805" height="243" alt="image" src="https://github.com/user-attachments/assets/45d68929-99a6-49de-a9be-95307c441fc4" />


### **아이디어 요약**

* 이 문제는 값 범위가 \*\*\[-10,000, 10,000]\*\*로 **좁고 고정(K=20001)** 입니다.
* 비교 정렬 `O(N log N)` 대신 **카운팅 배열**로 값을 세고, **작은 값부터 차례로 방문**하면 정렬 효과를 낼 수 있습니다.
* 정렬된 순서에서 원소를 **두 개씩 묶을 때 첫 번째(=그 쌍의 min)만 더하면** 되므로, 방문 중에 `take` 플래그를 토글하여 **첫 번째만 누적**합니다.

> 정의: `N = nums.length`, `K = MAX - MIN + 1 (=20001)`

---

### **풀이 요약**

1. 길이 `K`의 카운트 배열 `count`를 만들고 각 값의 빈도를 더한다.
2. `MIN`부터 `MAX`까지 올라가며, `count[v]`를 소진하는 동안

   * `take == true`인 경우에만 `sum += v` (쌍의 첫 번째)
   * 매번 원소 하나를 소비할 때마다 `take = !take` 토글
3. 모든 값을 소비하면 누적된 `sum`이 정답.

---

### **정당성(스케치)**

* **교환 논법**: 정렬된 배열에서 인접한 두 개씩 묶는 것이, 임의로 멀리 있는 값들과 묶는 것보다 각 쌍의 `min` 합을 **낮추지 않습니다**.
* 카운팅 스캔은 “정렬된 순서로 값이 나열된다”는 효과를 만드므로, **정렬+짝짓기와 동치**입니다.
* 따라서 정렬 풀이와 같은 최적값을 얻습니다.

---

### **복잡도**

* **시간**: 카운팅 `O(N)` + 범위 스캔 `O(K)` → **`O(N + K)`**
* **공간**: 카운팅 배열 `O(K)` → **`O(K)`**

> 값 범위가 좁을수록(고정 K) 사실상 `O(N)`에 가까운 성능.
> K가 매우 크면(예: 1e9) 오히려 비효율적이므로 정렬 풀이가 낫습니다.

---

### **Java 코드**

```java
// 비교 정렬 O(N log N) 대신, 값 범위(K=20001)를 이용해 O(N + K)로 해결하는 카운팅 스캔
// 아이디어: 정렬된 순서에서 2개씩 묶일 때, 각 쌍의 "첫 번째(=min)"만 누적
// 전체 시간복잡도: O(N + K), 전체 공간복잡도: O(K)
// (N = nums.length, K = MAX - MIN + 1)

class OptimizedSolution {
    private static final int MIN = -10000;
    private static final int MAX =  10000;
    private static final int OFFSET = -MIN;           // 10000
    private static final int SIZE   =  MAX - MIN + 1; // 20001

    public int arrayPairSum(int[] nums) {
        // 카운팅 배열 (JVM 0 초기화) — 시간 O(K), 공간 O(K)
        int[] count = new int[SIZE];

        // 입력 카운팅 — 시간 O(N), 공간 O(1)
        for (int v : nums) count[v + OFFSET]++;

        int sum = 0;
        boolean take = true; // true일 때 쌍의 첫 번째 → 누적

        // 값 범위를 작은 값부터 스캔 — for K회 + while 총합 N회 = O(N + K)
        for (int v = MIN; v <= MAX; v++) {
            int idx = v + OFFSET;
            while (count[idx] > 0) {
                if (take) sum += v; // 첫 번째만 더함(min)
                take = !take;       // 첫↔둘 번갈아 처리
                count[idx]--;       // 반드시 한 개 소비
            }
        }
        return sum;
    }
}
```

---

### **언제 이 풀이가 좋은가?**

* `N`이 크고 **값 범위 K가 작거나 고정**일 때(이 문제처럼).
* 메모리(`O(K)`)를 감당할 수 있을 때.

### **언제 정렬 풀이가 나을 수 있나?**

* 값 범위가 **매우 크거나 미상**일 때.
* `N`이 작아서 `O(N log N)`이 충분히 빠를 때.
* 코드 단순성을 우선할 때.

---

### **추가 미세 최적화(선택)**

* **조기 종료**: 남은 요소 수 `remain`을 추적, 모두 소비되면 `for` 탈출.
* **쌍 단위 언롤링**: 같은 값이 많이 나오면 `pairs = count/2` 만큼 한 번에 누적(분기 감소).
* **메모리 절약**: `short[] count`(전제: 카운트 최댓값 32767 이하).

---
